<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Lançamento de Projéteis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            max-width: 1200px;
            width: 100%;
            background-color: white;
            padding: 2.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }
        @media (min-width: 1024px) {
            .container {
                flex-direction: row;
            }
        }
        .sidebar {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            background-color: #f8fafc;
            padding: 2rem;
            border-radius: 1rem;
            border: 1px solid #e2e8f0;
        }
        .main-content {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        .results-grid {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 1.5rem;
        }
        @media (min-width: 768px) {
            .results-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (min-width: 1024px) {
            .results-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        .metric-card {
            background-color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 0.75rem;
            border: 1px solid #cbd5e1;
        }
        .metric-label {
            font-size: 1rem;
            font-weight: 500;
            color: #475569;
        }
        .metric-value {
            font-size: 1.75rem; /* Fonte menor aqui */
            font-weight: 700;
            color: #1e293b;
            margin-top: 0.5rem;
        }
        canvas {
            background-color: #f8fafc;
            border-radius: 1rem;
            border: 1px solid #e2e8f0;
            cursor: crosshair;
        }
        input[type="range"] {
            width: 100%;
        }
        .author-info {
            font-size: 0.875rem;
            color: #64748b;
        }
    </style>
</head>
<body>
    <div class="container">
        <aside class="sidebar">
            <h2 class="text-2xl font-bold mb-4 text-center text-gray-800">Parâmetros do Lançamento</h2>
            
            <div class="flex flex-col gap-2">
                <label for="height-slider" class="font-medium text-gray-700">Altura inicial (H, em m)</label>
                <input type="range" id="height-slider" min="0" max="100" value="50" step="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="height-value" class="text-gray-500 text-right">50.0 m</span>
            </div>

            <div class="flex flex-col gap-2">
                <label for="velocity-slider" class="font-medium text-gray-700">Velocidade inicial (v₀, em m/s)</label>
                <input type="range" id="velocity-slider" min="0" max="50" value="10" step="0.1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="velocity-value" class="text-gray-500 text-right">10.0 m/s</span>
            </div>

            <div class="flex flex-col gap-2">
                <label for="angle-slider" class="font-medium text-gray-700">Ângulo de Lançamento (α, em °)</label>
                <input type="range" id="angle-slider" min="0" max="90" value="0" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="angle-value" class="text-gray-500 text-right">0°</span>
            </div>

            <div class="flex flex-col gap-2">
                <label for="gravity-slider" class="font-medium text-gray-700">Aceleração da Gravidade (g, em m/s²)</label>
                <input type="range" id="gravity-slider" min="0" max="20" value="9.81" step="0.01" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="gravity-value" class="text-gray-500 text-right">9.81 m/s²</span>
            </div>

            <div class="flex items-center gap-2">
                <input type="checkbox" id="air-resistance-checkbox" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
                <label for="air-resistance-checkbox" class="font-medium text-gray-700">Resistência do Ar</label>
            </div>
            
            <div class="flex items-center gap-2">
                <input type="checkbox" id="show-vectors-checkbox" class="w-4 h-4 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500">
                <label for="show-vectors-checkbox" class="font-medium text-gray-700">Mostrar Vetores</label>
            </div>

            <div class="flex gap-4 mt-4">
                <button id="playPauseBtn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">Reproduzir</button>
                <button id="resetBtn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">Reiniciar</button>
            </div>
        </aside>

        <main class="main-content">
            <h1 class="text-4xl font-extrabold text-center mb-4 text-gray-900">Simulador de Lançamento de Projéteis</h1>
            
            <section>
                <h2 class="text-2xl font-bold mb-4 text-gray-800">Trajetória e Resultados</h2>
                <canvas id="trajectoryCanvas" width="800" height="450"></canvas>
            </section>
            
            <section class="results-grid">
                <div class="metric-card">
                    <div class="metric-label" id="first-metric-label">Tempo Total (T)</div>
                    <div class="metric-value" id="time-result">0.00 s</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label" id="second-metric-label">Alcance Horizontal (D)</div>
                    <div class="metric-value" id="range-result">0.00 m</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Velocidade Final ($$V_f$$)</div>
                    <div class="metric-value" id="final-velocity-result">0.00 m/s</div>
                </div>
            </section>
            
            <footer class="text-right author-info">
                Autor: Prof. Ojeda<br>
                Professor de Física, formado pela UFMT.
            </footer>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Constantes e elementos do DOM
            const gSlider = document.getElementById('gravity-slider');
            const heightSlider = document.getElementById('height-slider');
            const velocitySlider = document.getElementById('velocity-slider');
            const angleSlider = document.getElementById('angle-slider');
            const airResistanceCheckbox = document.getElementById('air-resistance-checkbox');
            const showVectorsCheckbox = document.getElementById('show-vectors-checkbox');
            const gValueSpan = document.getElementById('gravity-value');
            const heightValueSpan = document.getElementById('height-value');
            const velocityValueSpan = document.getElementById('velocity-value');
            const angleValueSpan = document.getElementById('angle-value');
            const timeResultDiv = document.getElementById('time-result');
            const rangeResultDiv = document.getElementById('range-result');
            const finalVelocityResultDiv = document.getElementById('final-velocity-result');
            const firstMetricLabel = document.getElementById('first-metric-label');
            const secondMetricLabel = document.getElementById('second-metric-label');
            const canvas = document.getElementById('trajectoryCanvas');
            const ctx = canvas.getContext('2d');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const resetBtn = document.getElementById('resetBtn');

            // Variáveis para a animação
            let animationId = null;
            let lastTime = 0;
            let elapsedTime = 0;
            let T = 0; // Tempo total de voo
            let D = 0; // Alcance total
            let H, v0, angle, g;
            let currentX, currentY, currentVx, currentVy;
            let v0x, v0y;
            let finalVelocity = 0;
            let apexTime = 0;
            let apexHeight = 0;
            const vectorScale = 5;

            // Constantes para a resistência do ar
            const ballMass = 1; // kg
            const dragCoefficient = 0.05;

            // Função para desenhar um vetor no canvas
            function drawVector(startX, startY, vecX, vecY, color, label) {
                // Converte coordenadas do mundo para o canvas
                const maxH = H + (v0y * v0y) / (2 * g);
                const maxD = (v0x * (v0y + Math.sqrt(v0y * v0y + 2 * g * H)) / g) || 200;
                const scaleX = canvas.width / (maxD + 10);
                const scaleY = canvas.height / (maxH + 10);
                const canvasX = startX * scaleX;
                const canvasY = canvas.height - (startY * scaleY);

                // Aplica a escala ao vetor
                const scaledVecX = vecX * vectorScale;
                const scaledVecY = vecY * vectorScale;

                // Calcula as coordenadas finais do vetor
                const endX = canvasX + scaledVecX;
                const endY = canvasY - scaledVecY; // Y é invertido no canvas

                // Desenha a linha do vetor
                ctx.beginPath();
                ctx.moveTo(canvasX, canvasY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Desenha a ponta da seta
                const angle = Math.atan2(endY - canvasY, endX - canvasX);
                ctx.save();
                ctx.translate(endX, endY);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 5);
                ctx.lineTo(-10, -5);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
                
                // Desenha o rótulo
                const labelX = endX + 15 * Math.cos(angle);
                const labelY = endY + 15 * Math.sin(angle);
                ctx.fillStyle = color;
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, labelX, labelY);
            }

            // Função para desenhar a trajetória e o projétil
            function drawScene() {
                // Limpa o canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Escala para ajustar a visualização
                const maxH = H + (v0y * v0y) / (2 * g);
                const maxD = (v0x * (v0y + Math.sqrt(v0y * v0y + 2 * g * H)) / g) || 200;

                const scaleX = canvas.width / (maxD + 10);
                const scaleY = canvas.height / (maxH + 10);

                // Desenha os eixos
                ctx.beginPath();
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 2;
                ctx.moveTo(0, canvas.height);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.moveTo(0, canvas.height);
                ctx.lineTo(0, 0);
                ctx.stroke();

                // Desenha a trajetória percorrida como uma linha pontilhada
                const numPoints = 200;
                ctx.beginPath();
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]); // Define o padrão de linha pontilhada

                // Lógica de cálculo da trajetória
                if (airResistanceCheckbox.checked) {
                    let tempX = 0;
                    let tempY = H;
                    let tempVx = v0x;
                    let tempVy = v0y;
                    let t = 0;
                    const dt = 0.01;

                    ctx.moveTo(0, canvas.height - (H * scaleY));

                    while (tempY >= 0 && t <= elapsedTime) {
                        const v = Math.sqrt(tempVx * tempVx + tempVy * tempVy);
                        const dragForceX = -dragCoefficient * tempVx;
                        const dragForceY = -dragCoefficient * tempVy;
                        const accelerationX = dragForceX / ballMass;
                        const accelerationY = -g + (dragForceY / ballMass);
                        
                        tempVx += accelerationX * dt;
                        tempVy += accelerationY * dt;
                        tempX += tempVx * dt;
                        tempY += tempVy * dt;
                        t += dt;
                        
                        const canvasX = tempX * scaleX;
                        const canvasY = canvas.height - (tempY * scaleY);
                        if (canvasY < canvas.height && canvasX < canvas.width) {
                             ctx.lineTo(canvasX, canvasY);
                        }
                    }
                } else {
                    const numPointsCompleted = Math.floor((elapsedTime / T) * numPoints);
                    for (let i = 0; i <= numPointsCompleted; i++) {
                        const t = (i / (numPoints - 1)) * T;
                        const x = v0x * t;
                        const y = H + v0y * t - 0.5 * g * t * t;
                        const canvasX = x * scaleX;
                        const canvasY = canvas.height - (y * scaleY);
                        if (i === 0) {
                            ctx.moveTo(canvasX, canvasY);
                        } else {
                            ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reseta o padrão para linhas sólidas

                // Converte para coordenadas do canvas
                const canvasX = currentX * scaleX;
                const canvasY = canvas.height - (currentY * scaleY);

                // Desenha os vetores se a opção estiver ativada
                if (showVectorsCheckbox.checked) {
                    drawVector(currentX, currentY, currentVx, currentVy, '#3b82f6', 'v'); // Vetor velocidade resultante (azul)
                    drawVector(currentX, currentY, currentVx, 0, '#22c55e', 'vx'); // Vetor componente x (verde)
                    drawVector(currentX, currentY, 0, currentVy, '#f97316', 'vy'); // Vetor componente y (laranja)
                }

                // Desenha o projétil
                ctx.beginPath();
                ctx.arc(canvasX, canvasY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = '#dc2626';
                ctx.fill();
            }

            // Loop de animação
            function animate(timestamp) {
                if (!lastTime) {
                    lastTime = timestamp;
                }
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;
                
                if (airResistanceCheckbox.checked) {
                    const dragForceX = -dragCoefficient * currentVx;
                    const dragForceY = -dragCoefficient * currentVy;
                    const accelerationX = dragForceX / ballMass;
                    const accelerationY = -g + (dragForceY / ballMass);
                    
                    currentVx += accelerationX * (deltaTime / 1000);
                    currentVy += accelerationY * (deltaTime / 1000);
                    currentX += currentVx * (deltaTime / 1000);
                    currentY += currentVy * (deltaTime / 1000);
                    elapsedTime += deltaTime / 1000;

                    if (currentY <= 0) {
                        currentY = 0;
                        cancelAnimationFrame(animationId);
                        animationId = null;
                        playPauseBtn.textContent = 'Reproduzir';
                        D = currentX;
                        T = elapsedTime;
                        // Calcula a velocidade final com resistência do ar
                        finalVelocity = Math.sqrt(currentVx * currentVx + currentVy * currentVy);
                    }
                    if (currentY > apexHeight) {
                        apexHeight = currentY;
                        apexTime = elapsedTime;
                    }
                } else {
                    elapsedTime += deltaTime / 1000; // Converte para segundos
                    if (elapsedTime >= T) {
                        elapsedTime = T;
                        cancelAnimationFrame(animationId);
                        animationId = null;
                        playPauseBtn.textContent = 'Reproduzir';
                    }
                    currentX = v0x * elapsedTime;
                    currentY = H + v0y * elapsedTime - 0.5 * g * elapsedTime * elapsedTime;
                    currentVx = v0x;
                    currentVy = v0y - g * elapsedTime;

                    if (currentVy <= 0 && angle > 0) {
                        apexHeight = currentY;
                        apexTime = elapsedTime;
                    }
                }
                
                drawScene();

                // Atualiza os valores dinâmicos nos cards
                if (angle == 0) {
                    timeResultDiv.textContent = `${elapsedTime.toFixed(2)} s`;
                    rangeResultDiv.textContent = `${currentX.toFixed(2)} m`;
                } else {
                    timeResultDiv.textContent = `${apexTime.toFixed(2)} s`;
                    rangeResultDiv.textContent = `${apexHeight.toFixed(2)} m`;
                }
                finalVelocityResultDiv.textContent = `${Math.sqrt(currentVx * currentVx + currentVy * currentVy).toFixed(2)} m/s`;


                if (animationId) {
                    animationId = requestAnimationFrame(animate);
                }
            }

            // Função para iniciar/pausar a animação
            function toggleAnimation() {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                    playPauseBtn.textContent = 'Reproduzir';
                } else {
                    lastTime = 0;
                    animationId = requestAnimationFrame(animate);
                    playPauseBtn.textContent = 'Pausar';
                }
            }
            
            // Função para reiniciar a simulação
            function resetSimulation() {
                cancelAnimationFrame(animationId);
                animationId = null;
                elapsedTime = 0;
                lastTime = 0;
                currentX = 0;
                currentY = H;
                currentVx = v0x;
                currentVy = v0y;
                finalVelocity = 0;
                apexHeight = H;
                apexTime = 0;
                playPauseBtn.textContent = 'Reproduzir';
                updateLabelsAndResults();
                drawScene();
            }

            // Função para atualizar as labels e os resultados finais
            function updateLabelsAndResults() {
                if (angle == 0) {
                    firstMetricLabel.textContent = 'Tempo Total (T)';
                    secondMetricLabel.textContent = 'Alcance Horizontal (D)';
                } else {
                    firstMetricLabel.textContent = 'Tempo p/ Altura Máx. ($$T_{max}$$)';
                    secondMetricLabel.textContent = 'Altura Máxima ($$H_{max}$$)';
                }

                // Cálculo do tempo de voo e alcance (sem resistência do ar)
                if (!airResistanceCheckbox.checked) {
                    const a = 0.5 * g;
                    const b = -v0y;
                    const c = -H;
                    const discriminant = b * b - 4 * a * c;

                    T = 0;
                    if (discriminant >= 0) {
                        const t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
                        const t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
                        T = Math.max(t1, t2);
                    }
                    D = v0x * T;

                    // Cálculo da velocidade final sem resistência do ar
                    const finalVy = v0y - g * T;
                    finalVelocity = Math.sqrt(v0x * v0x + finalVy * finalVy);

                    // Cálculo da altura e tempo máximos para lançamento oblíquo
                    apexTime = v0y / g;
                    if (apexTime < 0) {
                        apexTime = 0;
                    }
                    apexHeight = H + (v0y * v0y) / (2 * g);
                }

                // Exibe os resultados nos cards
                if (angle == 0) {
                    timeResultDiv.textContent = `${T.toFixed(2)} s`;
                    rangeResultDiv.textContent = `${D.toFixed(2)} m`;
                } else {
                    timeResultDiv.textContent = `${apexTime.toFixed(2)} s`;
                    rangeResultDiv.textContent = `${apexHeight.toFixed(2)} m`;
                }
                finalVelocityResultDiv.textContent = `${finalVelocity.toFixed(2)} m/s`;
            }

            // Função para atualizar todos os valores e reiniciar a simulação
            function updateSimulation() {
                H = parseFloat(heightSlider.value);
                v0 = parseFloat(velocitySlider.value);
                angle = parseFloat(angleSlider.value);
                g = parseFloat(gSlider.value);

                // Atualiza os valores ao lado dos sliders
                heightValueSpan.textContent = `${H.toFixed(1)} m`;
                velocityValueSpan.textContent = `${v0.toFixed(1)} m/s`;
                angleValueSpan.textContent = `${angle.toFixed(0)}°`;
                gValueSpan.textContent = `${g.toFixed(2)} m/s²`;

                const angleRad = angle * Math.PI / 180;
                v0x = v0 * Math.cos(angleRad);
                v0y = v0 * Math.sin(angleRad);

                resetSimulation();
            }

            // Adiciona event listeners aos sliders e botões
            heightSlider.addEventListener('input', updateSimulation);
            velocitySlider.addEventListener('input', updateSimulation);
            angleSlider.addEventListener('input', updateSimulation);
            gSlider.addEventListener('input', updateSimulation);
            airResistanceCheckbox.addEventListener('change', updateSimulation);
            showVectorsCheckbox.addEventListener('change', () => {
                resetSimulation();
            });
            playPauseBtn.addEventListener('click', toggleAnimation);
            resetBtn.addEventListener('click', updateSimulation);

            // Chamada inicial para desenhar com os valores padrão
            updateSimulation();
        });
    </script>
</body>
</html>
